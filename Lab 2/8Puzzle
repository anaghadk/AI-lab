import heapq

# --- Heuristic Functions ---
def misplaced_tiles(state, goal):
    return sum(1 for i in range(9) if state[i] != 0 and state[i] != goal[i])

def manhattan_distance(state, goal):
    distance = 0
    for i in range(9):
        if state[i] == 0:
            continue
        x1, y1 = divmod(i, 3)
        j = goal.index(state[i])
        x2, y2 = divmod(j, 3)
        distance += abs(x1 - x2) + abs(y1 - y2)
    return distance

# --- Puzzle Mechanics ---
def get_neighbors(state):
    neighbors = []
    zero_index = state.index(0)
    x, y = divmod(zero_index, 3)

    moves = [(-1,0), (1,0), (0,-1), (0,1)]
    for dx, dy in moves:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_index = nx * 3 + ny
            new_state = list(state)
            new_state[zero_index], new_state[new_index] = new_state[new_index], new_state[zero_index]
            neighbors.append(tuple(new_state))
    return neighbors

# --- Depth Limited Search ---
def dls(state, goal, limit, visited, path):
    if state == goal:
        return True
    if limit == 0:
        return False

    visited.add(state)
    for neighbor in get_neighbors(state):
        if neighbor not in visited:
            path.append(neighbor)
            if dls(neighbor, goal, limit - 1, visited, path):
                return True
            path.pop()
    return False

# --- Iterative Deepening DFS ---
def iddfs(start, goal, max_depth=30):
    for depth in range(max_depth + 1):
        visited = set()
        path = [start]
        if dls(start, goal, depth, visited, path):
            return path, depth
    return None, -1

# --- A* Search ---
def astar(start, goal, heuristic):
    open_set = []
    heapq.heappush(open_set, (heuristic(start, goal), 0, start, [start]))
    visited = set()

    while open_set:
        f, g, state, path = heapq.heappop(open_set)
        if state == goal:
            return path, g
        if state in visited:
            continue
        visited.add(state)

        for neighbor in get_neighbors(state):
            if neighbor not in visited:
                new_g = g + 1
                new_f = new_g + heuristic(neighbor, goal)
                heapq.heappush(open_set, (new_f, new_g, neighbor, path + [neighbor]))
    return None, -1

# --- Helper to Print Solution ---
def print_solution(name, path, moves):
    print("\n" + "="*40)
    print(f"  {name} RESULTS")
    print("="*40)

    if path:
        print(f"{name} found solution in {moves} moves!")
        for step, state in enumerate(path):
            print(f"\nStep {step}:")
            for i in range(0, 9, 3):
                print("  ", state[i:i+3])
    else:
        print(f"{name} failed to find a solution.")

# --- Main Runner ---
if __name__ == "__main__":
    start = (1, 2, 3,
             4, 0, 6,
             7, 5, 8)

    goal = (1, 2, 3,
            4, 5, 6,
            7, 8, 0)

    # Run IDDFS
    iddfs_path, iddfs_moves = iddfs(start, goal, max_depth=20)
    print_solution("IDDFS", iddfs_path, iddfs_moves)

    # Run A* with Misplaced Tiles
    misplaced_path, misplaced_moves = astar(start, goal, misplaced_tiles)
    print_solution("A* with Misplaced Tiles", misplaced_path, misplaced_moves)

    # Run A* with Manhattan Distance
    manhattan_path, manhattan_moves = astar(start, goal, manhattan_distance)
    print_solution("A* with Manhattan Distance", manhattan_path, manhattan_moves)
